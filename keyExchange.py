import random

primeNumber = 102188617217178804476387977160129334431745945009730065519337094992129677228373
primitiveRoot = 2


def diffie_hellman(p, g):
    # Public parameters: prime number (p) and primitive root (g)
    # These should be agreed upon by both users beforehand

    # Private keys for each user
    private_key_u1 = random.randint(2, p - 2)
    private_key_u2 = random.randint(2, p - 2)

    # Calculate public keys for each user using pow() for modular exponentiation
    public_key_u1 = pow(g, private_key_u1, p)
    public_key_u2 = pow(g, private_key_u2, p)

    # Shared secret calculation using pow() for modular exponentiation
    shared_secret_u1 = pow(public_key_u2, private_key_u1, p)
    shared_secret_u2 = pow(public_key_u1, private_key_u2, p)

    return shared_secret_u1, shared_secret_u2

shared_key_u1, shared_key_u2 = diffie_hellman(primeNumber, primitiveRoot)

print("Shared Key generated by User U1:", shared_key_u1)
print("Shared Key generated by User U2:", shared_key_u2)


class LFSR:
    def __init__(self, seed, taps):
        self.state = seed
        self.taps = taps

    def shift(self):
        feedback = sum(self.state[tap] for tap in self.taps) % 2
        self.state = [feedback] + self.state[:-1]
        return feedback

    def generate_key(self, length):
        key = []
        for _ in range(length):
            key.append(self.shift())
        return key

seed = [1, 0, 1, 0]  
shiftFeedbackPositions = [0, 2, 3]       
lfsr = LFSR(seed, shiftFeedbackPositions)
key_length = 16
generated_key = lfsr.generate_key(key_length)
print("Generated LFSR Key:", generated_key)