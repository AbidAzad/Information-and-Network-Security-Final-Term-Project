import random

primeNumber = 102188617217178804476387977160129334431745945009730065519337094992129677228373
primitiveRoot = 2

class User:
    pass

# Initialize two users
user1 = User()
user2 = User()

# DIFFIE-HELLMAN KEY EXCHANGE

# Users generate their Secret Key
user1.secret_integer = random.randint(2, primeNumber - 2)
user2.secret_integer = random.randint(2, primeNumber - 2)

# Users calculate their public keys using primitive root
user1.DHPublicKey = pow(primitiveRoot, user1.secret_integer, primeNumber)
user2.DHPublicKey = pow(primitiveRoot, user2.secret_integer, primeNumber)

# Users exchange their public keys
user1.receivedDHPublicKey = user2.DHPublicKey
user2.receivedDHPublicKey = user1.DHPublicKey

# Users calculate their shared secret key
user1.sharedSecret = pow(user1.receivedDHPublicKey, user1.secret_integer, primeNumber)
user2.sharedSecret = pow(user2.receivedDHPublicKey, user2.secret_integer, primeNumber)



print("Shared Key generated by User U1:", user1.sharedSecret)
print("Shared Key generated by User U2:", user2.sharedSecret)
print("User 1 is sharing the same key as User 2: "+(str(user1.sharedSecret == user2.sharedSecret)))



class LFSR:
    def __init__(self, seed, taps):
        self.state = seed
        self.taps = taps

    def shift(self):
        feedback = sum(self.state[tap] for tap in self.taps) % 2
        self.state = [feedback] + self.state[:-1]
        return feedback

    def generate_key(self, length):
        key = []
        for _ in range(length):
            key.append(self.shift())
        binary_string = ''.join(map(str, key))
        generated_key = int(binary_string, 2)
        return binary_string, generated_key

# Define the seed and feedback positions for the LFSR
seed = [1, 0, 1, 0]  
shiftFeedbackPositions = [0, 2, 3]       

# Create an instance of the LFSR class feedback positions
lfsr = LFSR(seed, shiftFeedbackPositions)

# Specify the length of the key
key_length = 16

# Generate a key of the specified length 
user1.generated_key_binary, user1.generated_key = lfsr.generate_key(key_length)

print("Generated LFSR Key:", user1.generated_key_binary)


#RSA Functions#
import math
from sympy import isprime
from gmpy2 import powmod

'''Helper function that generates a large prime number with the specified number of bits, in which for this assignment is 512.'''
def generate_large_prime(bits):
    while True:
        num = random.randrange(0, 2**bits - 1)
        if isprime(num):
            return num
'''Calculates the modular exponetiation of a given message, power, and basis using the 'powmod' function from the gmpy2 library'''
def exponentiation(message, power, basis):
    return powmod(message, power, basis)

'''Helper function that incorporates the extended euclidean algorithm to help determine the inverse value within the inverse_finder function.'''
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, x, y = extended_gcd(b % a, a)
        return g, y - (b // a) * x, x

'''Finds the modular inverse of a given number a modulo n using the extended euclidean algorithm.'''
def inverse_finder(a, n):
    g, x, _ = extended_gcd(a, n)
    if g != 1:
        raise ValueError(f"The modular inverse does not exist for {a} modulo {n}")
    else:
        return x % n
'''A function that generates RSA public and private keys. It takes an optional parameter e for the rsaKeyInput; if not provided, it defaults to 3.'''
def RSA_key_generate():
    e = 65537
    while(True):
        p = generate_large_prime(256)
        q = p
        
        while(p == q):
            q = generate_large_prime(256)
        n = p * q    
        euler = (p-1) * (q-1)
        
        if(math.gcd(euler, e) == 1):
            break
    d = inverse_finder(e, euler)
    publicKey = [e, n]
    privateKey = [d, n]
    return publicKey, privateKey

'''A function encrypts a numeric message or a string using RSA encryption with a given key.'''
def RSA_encrypt(message, key):
    if not isinstance(message, str):
        return exponentiation(message, key[0], key[1])
    elif isinstance(message, str):
        ciphertext = []
        for element in range(0, len(message)): 
            ciphertext.append(int(exponentiation(ord(message[element]), key[0], key[1])))
        return ciphertext

'''A function decrypts a numeric message or a list of numeric values using RSA decryption with a given key.'''
def RSA_decrypt(message, key):
    if not isinstance(message, str) and not isinstance(message, list):
        return RSA_encrypt(message, key)
    elif isinstance(message, list):
        decrpyted = ''
        for element in range(0, len(message)): 
            decrpyted+= chr(exponentiation(message[element], key[0], key[1]))
        return decrpyted

# User 1 generates RSA keys
user1.RSAPublicKey, user1.RSAPrivateKey = RSA_key_generate()

# User 1 encrypts his LFSR
encryptedMessage = RSA_encrypt(user1.generated_key_binary, user1.RSAPublicKey)

# Assume User 1 sends his encrypted message and private key to User 2.
# User 2 decrypts the message.
user2.receivedMessage = RSA_decrypt(encryptedMessage, user1.RSAPrivateKey)

# Check if the LFSR key was successfully sent through RSA
print("User 2 Recieved the Message: " +user2.receivedMessage)
print("Successfully sent LFSR Key Through RSA: " + str(user1.generated_key_binary == user2.receivedMessage))

def text_to_bits(text):
    return ''.join(format(ord(char), '08b') for char in text)

def bits_to_text(bits):
    return ''.join(chr(int(bits[i:i+8], 2)) for i in range(0, len(bits), 8))

# Stream Cipher
def encrypt(text, key):
    bits = text_to_bits(text)
    encrypted_bits = [int(bit) ^ int(key[i % len(key)]) for i, bit in enumerate(bits)]
    return ''.join(map(str, encrypted_bits))

def decrypt(ciphertext, key):
    decrypted_bits = [int(bit) ^ int(key[i % len(key)]) for i, bit in enumerate(ciphertext)]
    return bits_to_text(''.join(map(str, decrypted_bits)))

Messages = ["Hello!", 
            "Welcome to Introduction to Information and Network Security!", 
            "In the vast landscape of technology and innovation, the intertwining threads of progress and human ingenuity weave a narrative of constant evolution."]

#For Demo Purposes, lets use User 1's generated LFSR Key
for message in Messages:
    print("Original Message: "+message)
    encrypted = encrypt(message, user1.generated_key_binary)
    print("Encrypted Message: "+encrypted)
    decrypted = decrypt (encrypted, user1.generated_key_binary)
    print("Decrypted Message: "+decrypted)
    print("Successfully Encrypted and Decrypted Message: "+(str(message == decrypted)))

from AES import encrypt as aes_encrypt, decrypt as aes_decrypt
from cryptography.hazmat.primitives.ciphers import modes
#Using User 1's Shared Secret Key
#Format User 1's Key into a Bytes Object
integer_value = user1.sharedSecret
byte_value = integer_value.to_bytes((integer_value.bit_length() + 7) // 8, byteorder='big')
#Run the same tests using AES ECB
print("TESTS FOR AES ECB:")
for message in Messages:
    print("Original Message: "+message)
    encrypted = aes_encrypt(message, byte_value, modes.ECB())
    print("Encrypted Message: "+encrypted.decode())
    decrypted = aes_decrypt (encrypted, byte_value, modes.ECB())
    print("Decrypted Message: "+decrypted.decode())
    print("Successfully Encrypted and Decrypted Message: "+(str(message == decrypted.decode())))

import os
#Setup initialization vector for Cipher Block Chaining
iv = os.urandom(16)
print("TESTS FOR AES CBC:")
for message in Messages:
    print("Original Message: "+message)
    encrypted = aes_encrypt(message, byte_value, modes.CBC(iv))
    print("Encrypted Message: "+encrypted.decode())
    decrypted = aes_decrypt (encrypted, byte_value, modes.CBC(iv))
    print("Decrypted Message: "+decrypted.decode())
    print("Successfully Encrypted and Decrypted Message: "+(str(message == decrypted.decode())))

from DES import encrypt as des_encrypt, decrypt as des_decrypt
from Crypto.Cipher import DES

#Using a shorter key for DES
integer_value = random.getrandbits(64)
byte_value = integer_value.to_bytes((integer_value.bit_length() + 7) // 8, byteorder='big')
#Run the same tests using DES ECB
print("TESTS FOR DES ECB:")
for message in Messages:
    print("Original Message: "+message)
    encrypted = des_encrypt(message, byte_value, DES.MODE_ECB)
    print("Encrypted Message: "+encrypted.decode())
    decrypted = des_decrypt (encrypted, byte_value, DES.MODE_ECB)
    print("Decrypted Message: "+decrypted)
    print("Successfully Encrypted and Decrypted Message: "+(str(message == decrypted)))

import os
#Setup initialization vector for Cipher Block Chaining
iv = os.urandom(8)
print("TESTS FOR DES CBC:")
for message in Messages:
    print("Original Message: "+message)
    encrypted = des_encrypt(message, byte_value, DES.MODE_ECB, iv)
    print("Encrypted Message: "+encrypted.decode())
    decrypted = des_decrypt (encrypted, byte_value, DES.MODE_ECB, iv)
    print("Decrypted Message: "+decrypted)
    print("Successfully Encrypted and Decrypted Message: "+(str(message == decrypted)))

import hashlib
def hash_message(message):
    # Hash the message using SHA-256
    sha256 = hashlib.sha256()
    sha256.update(str(message).encode('utf-8'))
    return int(sha256.hexdigest(), 16)

def RSA_sign(message, private_key):
    hashed_message = hash_message(message)
    signature = exponentiation(hashed_message, private_key[0], private_key[1])
    return signature

def RSA_verify(message, signature, public_key):
    hashed_message = hash_message(message)
    decrypted_signature = exponentiation(signature, public_key[0], public_key[1])
    
    if hashed_message == decrypted_signature:
        return True
    else:
        return False
    

# User 1 wants to send a message to User 2.
Message = "Hi, User 2! Excited for Christmas?"

# User 1 encrypts his message using AES
integer_value = user1.sharedSecret
byte_value = integer_value.to_bytes((integer_value.bit_length() + 7) // 8, byteorder='big')
encryptedMessage = aes_encrypt(Message, byte_value, modes.ECB())

# User 1 signs his message using his RSA private key
Signature = RSA_sign(encryptedMessage, user1.RSAPrivateKey)

# User 1 sends his encrypted message and signature to User 2.

# User 2 receives the encrypted message and decrypts it.
# Note: User 2 can decrypt using the shared Diffie-Hellman key which is associated to byte_value.
decryptedMessage = aes_decrypt(encryptedMessage, byte_value, modes.ECB())
print("Received the message from User 1: " + str(decryptedMessage.decode()))

# User 2 verifies the authenticity of the message by checking the RSA signature.
verified = RSA_verify(encryptedMessage, Signature, user1.RSAPublicKey)

if verified:
    print("This message was indeed sent by User 1!")
else:
    print("This message was not verified!")

# User 1 wants to send a message to User 2.
Message = "Hi, User 2! Excited for Christmas?"

# User 1 encrypts his message using AES
integer_value = user1.sharedSecret
byte_value = integer_value.to_bytes((integer_value.bit_length() + 7) // 8, byteorder='big')
encryptedMessage = aes_encrypt(Message + "GRINCHED", byte_value, modes.ECB())

# User 1 signs his message using his RSA private key
Signature = RSA_sign(Message, user1.RSAPrivateKey)

# User 1 sends his encrypted message and signature to User 2.

# User 2 receives the encrypted message and decrypts it.
# Note: User 2 can decrypt using the shared Diffie-Hellman key which is associated to byte_value.
decryptedMessage = aes_decrypt(encryptedMessage, byte_value, modes.ECB())
print("Received the message from User 1: " + str(decryptedMessage.decode()))

# User 2 verifies the authenticity of the message by checking the RSA signature.
verified = RSA_verify(encryptedMessage, Signature, user1.RSAPublicKey)

if verified:
    print("This message was indeed sent by User 1!")
else:
    print("This message was not verified!")


import time

def RSA_sign_with_timestamp(message, private_key):
    # Include the current timestamp in the signature
    timestamp = time.time()
    
    # Convert the string message to bytes
    message_bytes = message.encode('utf-8')
    
    # Concatenate the message and timestamp as bytes
    combined_data = message_bytes + str(timestamp).encode('utf-8')

    # Hash the combined data
    hashed_message = hash_message(combined_data)
    
    # Create the signature
    signature = exponentiation(hashed_message, private_key[0], private_key[1])
    
    return signature, timestamp

def RSA_verify_with_timestamp(message, signature, timestamp, public_key, validity_period=3600):
    # Verify the timestamp
    current_time = time.time()
    if current_time - timestamp > validity_period:
        return False  # Signature is considered invalid if the timestamp is too old
    
    # Convert the string message to bytes
    message_bytes = message.encode('utf-8')
    
    # Concatenate the message and timestamp as bytes
    combined_data = message_bytes + str(timestamp).encode('utf-8')

    # Hash the combined data
    hashed_message = hash_message(combined_data)

    # Verify the signature
    decrypted_signature = exponentiation(signature, public_key[0], public_key[1])

    return hashed_message == decrypted_signature

# User 1 wants to send a message to User 2.
Message = "Hi, User 2! Excited for Christmas?"
encryptedMessage = aes_encrypt(Message , byte_value, modes.ECB())
# User 1 signs his message using his RSA private key WITH A TIMESTAMP!
Signature, Timestamp = RSA_sign_with_timestamp(Message, user1.RSAPrivateKey)

# User 1 sends his encrypted message and signature to User 2.

# User 2 receives the encrypted message and decrypts it.
# Note: User 2 can decrypt using the shared Diffie-Hellman key which is associated to byte_value.
decryptedMessage = aes_decrypt(encryptedMessage, byte_value, modes.ECB())
print("Received the message from User 1: " + str(decryptedMessage.decode()))

# User 2 verifies the authenticity of the message by checking the RSA signature AND TIME STAMP.
verified = RSA_verify_with_timestamp(decryptedMessage.decode('utf-8'), Signature, Timestamp, user1.RSAPublicKey)

if verified:
    print("This message was indeed sent by User 1 and is within the validity period!")
else:
    print("This message was not verified or is outside the validity period.")